{% extends 'base.html' %}

{% load custom_filters %}
{% load static %}

{% block title %}Faction Comparison{% endblock %}

{% block content %}
<h1>Workstat Effectiveness Over Time</h1>
<canvas id="workstatChart" width="900" height="400"></canvas>

<h1 style="margin-top: 40px;">Addiction Over Time (Last 2 Months)</h1>
<canvas id="addictionChart" width="900" height="400"></canvas>

<h1 style="margin-top: 40px;">7-Day Rolling Average Addiction (Daily)</h1>
<canvas id="avgAddictionChart" width="900" height="400"></canvas>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
<script>
    // Load employee data from context variable
    const rawData = {{ employee_data_json| safe }};

    // Calculate the date 2 months ago
    const now = new Date();
    const twoMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 2, now.getDate());
    const twoMonthsAgoStr = twoMonthsAgo.toISOString().slice(0, 10); // 'YYYY-MM-DD'

    // Group by employee and by day, keeping only the latest per day, and filter for last 2 months
    const grouped = {};
    rawData.forEach(row => {
        const empId = row.employee_id;
        const date = row.created_on.slice(0, 10); // 'YYYY-MM-DD'
        if (date < twoMonthsAgoStr) return; // skip if older than 2 months
        if (!grouped[empId]) grouped[empId] = {};
        // Only keep the latest per day (since data is ordered by created_on descending in the view)
        if (!grouped[empId][date] || grouped[empId][date].created_on < row.created_on) {
            grouped[empId][date] = row;
        }
    });

    // Prepare datasets for Chart.js (Workstats)
    const colors = [
        '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
        '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080'
    ];
    const datasets = Object.keys(grouped).map((empId, idx) => {
        const data = Object.values(grouped[empId]).map(row => ({
            x: row.created_on.slice(0, 10),
            y: row.effectiveness_working_stats,
            manual: row.manual_labour,
            intelligence: row.intelligence,
            endurance: row.endurance
        }));
        return {
            label: Object.values(grouped[empId])[0].name,
            data: data,
            showLine: true,
            borderColor: colors[idx % colors.length],
            backgroundColor: colors[idx % colors.length],
            tension: 0.2,
            pointRadius: 4
        };
    });

    // Create Workstats Chart
    const ctx = document.getElementById('workstatChart').getContext('2d');
    new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: datasets
        },
        options: {
            plugins: {
                legend: { display: true },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const d = context.raw;
                            return [
                                `${context.dataset.label}`,
                                `Date: ${d.x}`,
                                `Effectiveness: ${d.y}`,
                                `Manual: ${d.manual}`,
                                `Intelligence: ${d.intelligence}`,
                                `Endurance: ${d.endurance}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day' },
                    adapters: { date: window.luxon },
                    title: { display: true, text: 'Date' }
                },
                y: {
                    title: { display: true, text: 'Effectiveness Working Stats' }
                }
            }
        }
    });

    // Prepare datasets for Addiction Chart (same time period as workstats)
    const addictionDatasets = Object.keys(grouped).map((empId, idx) => {
        const data = Object.values(grouped[empId]).map(row => ({
            x: row.created_on.slice(0, 10),
            y: Math.abs(row.effectiveness_addiction), // Make addiction positive
            manual: row.manual_labour,
            intelligence: row.intelligence,
            endurance: row.endurance
        }));
        return {
            label: Object.values(grouped[empId])[0].name,
            data: data,
            showLine: true,
            borderColor: colors[idx % colors.length],
            backgroundColor: colors[idx % colors.length],
            tension: 0.2,
            pointRadius: 4
        };
    });

    // Create Addiction Chart
    const ctx2 = document.getElementById('addictionChart').getContext('2d');
    
    // Get the full date range from all datasets
    let minDate = null;
    let maxDate = null;
    addictionDatasets.forEach(dataset => {
        dataset.data.forEach(point => {
            if (!minDate || point.x < minDate) minDate = point.x;
            if (!maxDate || point.x > maxDate) maxDate = point.x;
        });
    });
    
    // Add trend line dataset at -10 (which becomes 10 when made positive)
    const trendLineData = {
        label: 'Trend Line (10)',
        data: minDate && maxDate ? [
            { x: minDate, y: 10 },
            { x: maxDate, y: 10 }
        ] : [],
        borderColor: 'red',
        backgroundColor: 'red',
        borderWidth: 2,
        borderDash: [5, 5],
        pointRadius: 0,
        showLine: true,
        tension: 0
    };
    
    new Chart(ctx2, {
        type: 'scatter',
        data: {
            datasets: [...addictionDatasets, trendLineData]
        },
        options: {
            plugins: {
                legend: { display: true },
                tooltip: {
                    filter: function(tooltipItem) {
                        return tooltipItem.datasetIndex !== addictionDatasets.length; // Hide tooltip for trend line
                    },
                    callbacks: {
                        label: function (context) {
                            const d = context.raw;
                            return [
                                `${context.dataset.label}`,
                                `Date: ${d.x}`,
                                `Addiction: ${d.y}`,
                                `Manual: ${d.manual}`,
                                `Intelligence: ${d.intelligence}`,
                                `Endurance: ${d.endurance}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day' },
                    adapters: { date: window.luxon },
                    title: { display: true, text: 'Date' }
                },
                y: {
                    title: { display: true, text: 'Addiction (Positive Values)' }
                }
            }
        }
    });

    // Find people with current addiction <= -8 (high addiction)
    const highAddictionPeople = [];
    Object.keys(grouped).forEach(empId => {
        const employeeData = Object.values(grouped[empId]);
        if (employeeData.length > 0) {
            // Get most recent data for this employee
            const latestData = employeeData.reduce((latest, current) => 
                current.created_on > latest.created_on ? current : latest
            );
            const originalAddiction = latestData.effectiveness_addiction; // Original negative value
            const absoluteAddiction = Math.abs(originalAddiction);
            // Check if original addiction is -8 or lower (meaning high addiction)
            if (originalAddiction <= -8) {
                highAddictionPeople.push({
                    name: latestData.name,
                    employeeId: latestData.employee_id,
                    addiction: absoluteAddiction.toFixed(2),
                    originalValue: originalAddiction.toFixed(2),
                    date: latestData.created_on.slice(0, 10)
                });
            }
        }
    });

    // Display high addiction alert if there are any
    if (highAddictionPeople.length > 0) {
        const alertDiv = document.createElement('div');
        alertDiv.className = 'alert alert-warning mt-3 mb-3';
        alertDiv.innerHTML = `
            <h5><i class="fas fa-exclamation-triangle"></i> High Addiction Alert (â‰¤-8)</h5>
            <ul class="mb-0">
                ${highAddictionPeople.map(person => 
                    `<li><strong><a href="https://www.torn.com/messages.php#/p=compose&XID=${person.employeeId}" target="_blank" style="color: #856404; text-decoration: none;">${person.name}</a></strong>: ${person.addiction} (original: ${person.originalValue}) (as of ${person.date})</li>`
                ).join('')}
            </ul>
        `;
        // Insert the alert before the addiction chart canvas
        const addictionChart = document.getElementById('addictionChart');
        addictionChart.parentNode.insertBefore(alertDiv, addictionChart);
    }

    // Calculate 7-day rolling average addiction for the previous 7 days
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const fourteenDaysAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
    const sevenDaysAgoStr = sevenDaysAgo.toISOString().slice(0, 10);
    const fourteenDaysAgoStr = fourteenDaysAgo.toISOString().slice(0, 10);

    // Group data for rolling average calculation (need 14 days of data)
    const rollingAvgGrouped = {};
    rawData.forEach(row => {
        const empId = row.employee_id;
        const date = row.created_on.slice(0, 10);
        if (date < fourteenDaysAgoStr) return; // skip if older than 14 days
        if (!rollingAvgGrouped[empId]) rollingAvgGrouped[empId] = {};
        if (!rollingAvgGrouped[empId][date] || rollingAvgGrouped[empId][date].created_on < row.created_on) {
            rollingAvgGrouped[empId][date] = row;
        }
    });

    // Calculate 7-day rolling averages for each employee for each of the last 7 days
    const rollingAvgData = Object.keys(rollingAvgGrouped).map((empId, idx) => {
        const employeeData = Object.values(rollingAvgGrouped[empId]);
        const employeeName = employeeData[0].name;
        
        // Sort data by date
        employeeData.sort((a, b) => a.created_on.localeCompare(b.created_on));
        
        const rollingAverages = [];
        
        // For each of the last 7 days, calculate the 7-day average ending on that day
        for (let i = 0; i < 7; i++) {
            const targetDate = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
            const targetDateStr = targetDate.toISOString().slice(0, 10);
            
            // Get 7 days of data ending on this target date
            const sevenDaysPrior = new Date(targetDate.getTime() - 6 * 24 * 60 * 60 * 1000);
            const sevenDaysPriorStr = sevenDaysPrior.toISOString().slice(0, 10);
            
            // Filter data for this 7-day window
            const windowData = employeeData.filter(row => {
                const rowDate = row.created_on.slice(0, 10);
                return rowDate >= sevenDaysPriorStr && rowDate <= targetDateStr;
            });
            
            // Calculate average for this window
            if (windowData.length > 0) {
                const avgAddiction = windowData.reduce((sum, row) => sum + Math.abs(row.effectiveness_addiction), 0) / windowData.length;
                rollingAverages.push({
                    x: targetDateStr,
                    y: avgAddiction
                });
            }
        }
        
        // Reverse to show oldest to newest
        rollingAverages.reverse();
        
        return {
            label: employeeName,
            data: rollingAverages,
            borderColor: colors[idx % colors.length],
            backgroundColor: colors[idx % colors.length],
            showLine: true,
            tension: 0.2,
            pointRadius: 4
        };
    });

    // Create 7-Day Rolling Average Addiction Chart
    const ctx3 = document.getElementById('avgAddictionChart').getContext('2d');
    new Chart(ctx3, {
        type: 'scatter',
        data: {
            datasets: rollingAvgData
        },
        options: {
            plugins: {
                legend: { display: true },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            return [
                                `${context.dataset.label}`,
                                `Date: ${context.raw.x}`,
                                `7-Day Avg Addiction: ${context.raw.y.toFixed(2)}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day' },
                    adapters: { date: window.luxon },
                    title: { display: true, text: 'Date' }
                },
                y: {
                    title: { display: true, text: '7-Day Rolling Average Addiction' }
                }
            }
        }
    });
</script>
{% endblock %}