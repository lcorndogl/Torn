{% extends 'base.html' %}

{% load custom_filters %}
{% load static %}

{% block title %}Faction Comparison{% endblock %}

{% block content %}
<!-- Date Range Selection -->
<div class="container-fluid mb-4">
    <div class="row justify-content-center">
        <div class="col-md-8 col-lg-6">
            <div class="card">
                <div class="card-body text-center">
                    <h5 class="card-title">Select Date Range</h5>
                    <div class="row">
                        <div class="col-md-4">
                            <label for="startDate" class="form-label">Start Date:</label>
                            <input type="date" id="startDate" class="form-control">
                        </div>
                        <div class="col-md-4">
                            <label for="endDate" class="form-label">End Date:</label>
                            <input type="date" id="endDate" class="form-control">
                        </div>
                        <div class="col-md-4 d-flex align-items-end">
                            <button id="updateCharts" class="btn btn-primary me-2">Update</button>
                            <button id="resetRange" class="btn btn-secondary">Reset</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Stat Reductions Alert Grid -->
<div class="container-fluid mb-4">
    <h2 class="text-center mb-4">Stat Reductions Overview</h2>
    <div class="row d-flex">
        <div class="col-md-4 d-flex">
            <div class="alert alert-danger flex-fill text-center">
                <h5 class="mb-3"><i class="fas fa-exclamation-triangle"></i> Total Reductions Summary</h5>
                <div id="totalReductionsAlerts">
                    <!-- Total reductions alerts will be inserted here -->
                </div>
            </div>
        </div>
        <div class="col-md-4 d-flex">
            <div class="alert alert-warning flex-fill text-center">
                <h5 class="mb-3"><i class="fas fa-exclamation-triangle"></i> Current Addictions (≤ -6)</h5>
                <div id="addictionAlerts">
                    <!-- Addiction alerts will be inserted here -->
                </div>
            </div>
        </div>
        <div class="col-md-4 d-flex">
            <div class="alert alert-info flex-fill text-center">
                <h5 class="mb-3"><i class="fas fa-info-circle"></i> Current Inactivity Risks</h5>
                <div id="inactivityAlerts">
                    <!-- Inactivity alerts will be inserted here -->
                </div>
            </div>
        </div>
    </div>
</div>

<h1 class="text-center">Workstat Effectiveness Over Time</h1>
<canvas id="workstatChart" width="900" height="400"></canvas>

<h1 class="text-center" style="margin-top: 40px;">Addiction Over Time</h1>
<canvas id="addictionChart" width="900" height="400"></canvas>

<h1 class="text-center" style="margin-top: 40px;">7-Day Rolling Average Addiction (Daily)</h1>
<canvas id="avgAddictionChart" width="900" height="400"></canvas>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
<script>
    // Load employee data from context variable
    const rawData = {{ employee_data_json| safe }};
    const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'olive', 'cyan'];
    const now = new Date(); // Define now variable for any remaining old code references
    
    // Chart instances to destroy on update
    let workstatChart, addictionChart, rollingAvgChart;
    
    // Initialize date inputs with default range (last 30 days)
    function initializeDateInputs() {
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        
        document.getElementById('endDate').value = now.toISOString().slice(0, 10);
        document.getElementById('startDate').value = thirtyDaysAgo.toISOString().slice(0, 10);
    }
    
    // Filter data based on selected date range
    function filterDataByDateRange(data, startDate, endDate) {
        return data.filter(row => {
            const rowDate = row.created_on.slice(0, 10);
            return rowDate >= startDate && rowDate <= endDate;
        });
    }
    
    // Main function to create all charts
    function createCharts() {
        console.log('createCharts function called');
        
        // Get selected date range
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        console.log('Start date:', startDate, 'End date:', endDate);
        
        if (!startDate || !endDate) {
            alert('Please select both start and end dates');
            return;
        }
        
        if (startDate > endDate) {
            alert('Start date cannot be after end date');
            return;
        }
        
        // Filter data for selected range
        const filteredData = filterDataByDateRange(rawData, startDate, endDate);
        console.log('Filtered data length:', filteredData.length);
        
        if (filteredData.length === 0) {
            alert('No data available for the selected date range');
            return;
        }
        
        // Destroy existing charts
        console.log('Destroying existing charts...');
        if (workstatChart) {
            workstatChart.destroy();
            console.log('Workstat chart destroyed');
        }
        if (addictionChart) {
            addictionChart.destroy();
            console.log('Addiction chart destroyed');
        }
        if (rollingAvgChart) {
            rollingAvgChart.destroy();
            console.log('Rolling avg chart destroyed');
        }
        
        // Create charts and populate alerts with filtered data
        console.log('Creating new charts and populating alerts...');
        populateStatReductionAlerts(filteredData);
        createWorkstatChart(filteredData);
        createAddictionChart(filteredData);
        createRollingAverageChart(filteredData, startDate, endDate);
        console.log('Charts creation complete');
    }
    
    function populateStatReductionAlerts(data) {
        // Group by employee and by day, keeping only the latest per day
        const grouped = {};
        data.forEach(row => {
            const empId = row.employee_id;
            const date = row.created_on.slice(0, 10);
            if (!grouped[empId]) grouped[empId] = {};
            if (!grouped[empId][date] || grouped[empId][date].created_on < row.created_on) {
                grouped[empId][date] = row;
            }
        });

        // Find people with current total reductions <= -8 (only current members)
        const totalReductionPeople = [];
        Object.keys(grouped).forEach(empId => {
            const employeeData = Object.values(grouped[empId]);
            if (employeeData.length > 0) {
                const latestData = employeeData.reduce((latest, current) => 
                    current.created_on > latest.created_on ? current : latest
                );
                // Only include current members for alerts
                if (latestData.is_current_member) {
                    const totalReduction = latestData.effectiveness_inactivity + latestData.effectiveness_addiction;
                    if (latestData.effectiveness_addiction <= -8 || latestData.effectiveness_inactivity < 0) {
                        totalReductionPeople.push({
                            name: latestData.name,
                            employeeId: latestData.employee_id,
                            totalReduction: totalReduction.toFixed(2),
                            inactivity: latestData.effectiveness_inactivity.toFixed(2),
                            addiction: latestData.effectiveness_addiction.toFixed(2),
                            date: latestData.created_on.slice(0, 10)
                        });
                    }
                }
            }
        });

        // Find people with current addiction <= -6 (only current members)
        const highAddictionPeople = [];
        Object.keys(grouped).forEach(empId => {
            const employeeData = Object.values(grouped[empId]);
            if (employeeData.length > 0) {
                const latestData = employeeData.reduce((latest, current) => 
                    current.created_on > latest.created_on ? current : latest
                );
                // Only include current members for alerts
                if (latestData.is_current_member) {
                    const originalAddiction = latestData.effectiveness_addiction;
                    if (originalAddiction <= -6) {
                        highAddictionPeople.push({
                            name: latestData.name,
                            employeeId: latestData.employee_id,
                            addiction: Math.abs(originalAddiction).toFixed(2),
                            originalValue: originalAddiction.toFixed(2),
                            date: latestData.created_on.slice(0, 10)
                        });
                    }
                }
            }
        });

        // Find people with current inactivity < 0 OR last action before 18:00 the previous day (only current members)
        // Note: Now filtering to only include current members while preserving historical data for charts
        const inactivityPeople = [];
        const currentTime = new Date(); // This will be in local time
        
        // Convert to GMT for consistent timezone handling
        const currentTimeGMT = new Date(currentTime.getTime() + (currentTime.getTimezoneOffset() * 60000));
        const currentHourGMT = currentTimeGMT.getUTCHours();
        const currentMinuteGMT = currentTimeGMT.getUTCMinutes();
        
        // Check if current time is 18:16 GMT or later (since data script runs at xx:15 and xx:22)
        const isAfter1816GMT = (currentHourGMT > 18) || (currentHourGMT === 18 && currentMinuteGMT >= 16);
        
        // Determine the cutoff time based on current GMT time (but always use 18:00 for comparison)
        let cutoffTime;
        if (!isAfter1816GMT) {
            // If current GMT time is before 18:16, check for last action before 18:00 the day before (GMT)
            cutoffTime = new Date(currentTimeGMT);
            cutoffTime.setUTCDate(cutoffTime.getUTCDate() - 1);
            cutoffTime.setUTCHours(18, 0, 0, 0);
        } else {
            // If current GMT time is 18:16 or later, check for last action before 18:00 on current day (GMT)
            cutoffTime = new Date(currentTimeGMT);
            cutoffTime.setUTCHours(18, 0, 0, 0);
        }
        
        // Check only current members for inactivity alerts
        Object.keys(grouped).forEach(empId => {
            const employeeData = Object.values(grouped[empId]);
            if (employeeData.length > 0) {
                const latestData = employeeData.reduce((latest, current) => 
                    current.created_on > latest.created_on ? current : latest
                );
                
                // Only include current members for alerts
                if (latestData.is_current_member) {
                    const inactivity = latestData.effectiveness_inactivity;
                    
                    let shouldInclude = false;
                    let reason = '';
                    
                    // Check if user has inactivity issues OR last action was before the cutoff time
                    if (inactivity < 0) {
                        shouldInclude = true;
                        reason = 'Inactivity < 0';
                    }
                    
                    if (latestData.last_action_timestamp) {
                        const lastActionTime = new Date(latestData.last_action_timestamp);
                        // Convert last action time to GMT for comparison
                        const lastActionTimeGMT = new Date(lastActionTime.getTime() + (lastActionTime.getTimezoneOffset() * 60000));
                        
                        if (lastActionTimeGMT < cutoffTime) {
                            shouldInclude = true;
                            const timeCondition = !isAfter1816GMT ? 'before 18:00 yesterday (GMT)' : 'before 18:00 today (GMT)';
                            if (reason) {
                                reason += ` & ${timeCondition}`;
                            } else {
                                reason = `Last action ${timeCondition}`;
                            }
                        }
                    }
                    
                    if (shouldInclude) {
                        // Calculate hours since last action (using GMT)
                        const lastActionTime = latestData.last_action_timestamp ? new Date(latestData.last_action_timestamp) : null;
                        const lastActionTimeGMT = lastActionTime ? new Date(lastActionTime.getTime() + (lastActionTime.getTimezoneOffset() * 60000)) : null;
                        const hoursSinceLastAction = lastActionTimeGMT ? Math.floor((currentTimeGMT - lastActionTimeGMT) / (1000 * 60 * 60)) : 'Unknown';
                        
                        inactivityPeople.push({
                            name: latestData.name,
                            employeeId: latestData.employee_id,
                            inactivity: inactivity.toFixed(2),
                            date: latestData.created_on.slice(0, 10),
                            lastActionTime: lastActionTime ? lastActionTime.toLocaleString() : 'No timestamp',
                            hoursSinceAction: hoursSinceLastAction,
                            reason: reason,
                            currentTimeGMT: currentTimeGMT.toISOString(),
                            cutoffTimeGMT: cutoffTime.toISOString()
                        });
                    }
                }
            }
        });

        // Populate Total Reductions Alert (using danger colors)
        const totalReductionsDiv = document.getElementById('totalReductionsAlerts');
        if (totalReductionPeople.length > 0) {
            totalReductionsDiv.innerHTML = `
                <ul class="list-unstyled mb-0" style="text-align: center;">
                    ${totalReductionPeople.map(person => 
                        `<li class="mb-2"><strong><a href="https://www.torn.com/profiles.php?XID=${person.employeeId}" target="_blank" style="color: #721c24; text-decoration: none;">${person.name}</a></strong> (${person.date})<br>
                        <small style="color: #721c24;">Total: ${person.totalReduction} (Inactivity: ${person.inactivity}, Addiction: ${person.addiction})</small></li>`
                    ).join('')}
                </ul>
            `;
        } else {
            totalReductionsDiv.innerHTML = '<p style="color: #721c24; text-align: center;" class="mb-0">No employees with total reductions ≤ -8</p>';
        }

        // Populate Addiction Alert (using warning colors)
        const addictionDiv = document.getElementById('addictionAlerts');
        if (highAddictionPeople.length > 0) {
            addictionDiv.innerHTML = `
                <ul class="list-unstyled mb-0" style="text-align: center;">
                    ${highAddictionPeople.map(person => 
                        `<li class="mb-2"><strong><a href="https://www.torn.com/messages.php#/p=compose&XID=${person.employeeId}" target="_blank" style="color: #856404; text-decoration: none;">${person.name}</a></strong> (${person.date})<br>
                        <small style="color: #856404;">Addiction: ${person.addiction} (original: ${person.originalValue})</small></li>`
                    ).join('')}
                </ul>
            `;
        } else {
            addictionDiv.innerHTML = '<p style="color: #856404; text-align: center;" class="mb-0">No employees with addiction ≤ -6</p>';
        }

        // Populate Inactivity Alert (using info colors)
        const inactivityDiv = document.getElementById('inactivityAlerts');
        if (inactivityPeople.length > 0) {
            // Check if we're after 18:16 GMT to determine if we should limit display
            const currentTime = new Date();
            const currentTimeGMT = new Date(currentTime.getTime() + (currentTime.getTimezoneOffset() * 60000));
            const currentHourGMT = currentTimeGMT.getUTCHours();
            const currentMinuteGMT = currentTimeGMT.getUTCMinutes();
            const isAfter1816GMT = (currentHourGMT > 18) || (currentHourGMT === 18 && currentMinuteGMT >= 16);
            
            if (isAfter1816GMT && inactivityPeople.length > 2) {
                // Separate people with inactivity < 0 from those with only time issues
                const inactivityIssues = inactivityPeople.filter(person => parseFloat(person.inactivity) < 0);
                const timeOnlyIssues = inactivityPeople.filter(person => parseFloat(person.inactivity) >= 0);
                
                // Sort time-only issues by hours since last action (highest first)
                const sortedTimeIssues = timeOnlyIssues.sort((a, b) => {
                    const hoursA = typeof a.hoursSinceAction === 'number' ? a.hoursSinceAction : 9999;
                    const hoursB = typeof b.hoursSinceAction === 'number' ? b.hoursSinceAction : 9999;
                    return hoursB - hoursA;
                });
                
                // Always show all inactivity issues + top 2 time-only issues
                const alwaysShow = [...inactivityIssues, ...sortedTimeIssues.slice(0, 2)];
                const remaining = sortedTimeIssues.slice(2);
                
                if (remaining.length > 0) {
                    inactivityDiv.innerHTML = `
                        <ul class="list-unstyled mb-0" style="text-align: center;" id="topList">
                            ${alwaysShow.map(person => 
                                `<li class="mb-2"><strong><a href="https://www.torn.com/profiles.php?XID=${person.employeeId}" target="_blank" style="color: #0c5460; text-decoration: none;">${person.name}</a></strong> (${person.date})<br>
                                <small style="color: #0c5460;">Inactivity: ${person.inactivity}<br>Last Action: ${person.lastActionTime}<br>Hours Since: ${person.hoursSinceAction}<br>Reason: ${person.reason}</small></li>`
                            ).join('')}
                        </ul>
                        <div class="mt-2">
                            <button id="expandInactivityBtn" class="btn btn-sm btn-outline-info" onclick="toggleInactivityExpand()">
                                Show ${remaining.length} more members
                            </button>
                        </div>
                        <ul class="list-unstyled mb-0" style="text-align: center; display: none;" id="remainingList">
                            ${remaining.map(person => 
                                `<li class="mb-2"><strong><a href="https://www.torn.com/profiles.php?XID=${person.employeeId}" target="_blank" style="color: #0c5460; text-decoration: none;">${person.name}</a></strong> (${person.date})<br>
                                <small style="color: #0c5460;">Inactivity: ${person.inactivity}<br>Last Action: ${person.lastActionTime}<br>Hours Since: ${person.hoursSinceAction}<br>Reason: ${person.reason}</small></li>`
                            ).join('')}
                        </ul>
                    `;
                } else {
                    // Show all members (no remaining to hide)
                    inactivityDiv.innerHTML = `
                        <ul class="list-unstyled mb-0" style="text-align: center;">
                            ${alwaysShow.map(person => 
                                `<li class="mb-2"><strong><a href="https://www.torn.com/profiles.php?XID=${person.employeeId}" target="_blank" style="color: #0c5460; text-decoration: none;">${person.name}</a></strong> (${person.date})<br>
                                <small style="color: #0c5460;">Inactivity: ${person.inactivity}<br>Last Action: ${person.lastActionTime}<br>Hours Since: ${person.hoursSinceAction}<br>Reason: ${person.reason}</small></li>`
                            ).join('')}
                        </ul>
                    `;
                }
            } else {
                // Show all members (either before 18:16 GMT or 2 or fewer members)
                inactivityDiv.innerHTML = `
                    <ul class="list-unstyled mb-0" style="text-align: center;">
                        ${inactivityPeople.map(person => 
                            `<li class="mb-2"><strong><a href="https://www.torn.com/profiles.php?XID=${person.employeeId}" target="_blank" style="color: #0c5460; text-decoration: none;">${person.name}</a></strong> (${person.date})<br>
                            <small style="color: #0c5460;">Inactivity: ${person.inactivity}<br>Last Action: ${person.lastActionTime}<br>Hours Since: ${person.hoursSinceAction}<br>Reason: ${person.reason}</small></li>`
                        ).join('')}
                    </ul>
                `;
            }
        } else {
            const currentTime = new Date();
            const currentTimeGMT = new Date(currentTime.getTime() + (currentTime.getTimezoneOffset() * 60000));
            const currentHourGMT = currentTimeGMT.getUTCHours();
            const currentMinuteGMT = currentTimeGMT.getUTCMinutes();
            const isAfter1816GMT = (currentHourGMT > 18) || (currentHourGMT === 18 && currentMinuteGMT >= 16);
            const timeCondition = !isAfter1816GMT ? 'before 18:00 yesterday (GMT)' : 'before 18:00 today (GMT)';
            inactivityDiv.innerHTML = `<p style="color: #0c5460; text-align: center;" class="mb-0">No current members with inactivity < 0 or last action ${timeCondition}</p>`;
        }
    }
    
    function createWorkstatChart(data) {
        // First, identify which employees are current members
        const currentMemberIds = new Set();
        data.forEach(row => {
            if (row.is_current_member) {
                currentMemberIds.add(row.employee_id);
            }
        });
        
        // Filter data to only include current members
        const currentMemberData = data.filter(row => currentMemberIds.has(row.employee_id));
        
        // Group by employee and by day, keeping only the latest per day
        const grouped = {};
        currentMemberData.forEach(row => {
            const empId = row.employee_id;
            const date = row.created_on.slice(0, 10);
            if (!grouped[empId]) grouped[empId] = {};
            if (!grouped[empId][date] || grouped[empId][date].created_on < row.created_on) {
                grouped[empId][date] = row;
            }
        });

        // Prepare datasets for Chart.js (Workstats)
        const datasets = Object.keys(grouped).map((empId, idx) => {
            const data = Object.values(grouped[empId]).map(row => ({
                x: row.created_on.slice(0, 10),
                y: row.effectiveness_working_stats,
                manual: row.manual_labour,
                intelligence: row.intelligence,
                endurance: row.endurance
            }));
            return {
                label: Object.values(grouped[empId])[0].name,
                data: data,
                showLine: true,
                borderColor: colors[idx % colors.length],
                backgroundColor: colors[idx % colors.length],
                tension: 0.2,
                pointRadius: 4
            };
        });

        // Create Workstats Chart
        const ctx = document.getElementById('workstatChart').getContext('2d');
        workstatChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: datasets
        },
        options: {
            plugins: {
                legend: { display: true },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const d = context.raw;
                            return [
                                `${context.dataset.label}`,
                                `Date: ${d.x}`,
                                `Effectiveness: ${d.y}`,
                                `Manual: ${d.manual}`,
                                `Intelligence: ${d.intelligence}`,
                                `Endurance: ${d.endurance}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day' },
                    adapters: { date: window.luxon },
                    title: { display: true, text: 'Date' }
                },
                y: {
                    title: { display: true, text: 'Effectiveness Working Stats' }
                }
            }
        }
    });

    // Prepare datasets for Addiction Chart (same time period as workstats)
    const addictionDatasets = Object.keys(grouped).map((empId, idx) => {
        const data = Object.values(grouped[empId]).map(row => ({
            x: row.created_on.slice(0, 10),
            y: Math.abs(row.effectiveness_addiction), // Make addiction positive
            manual: row.manual_labour,
            intelligence: row.intelligence,
            endurance: row.endurance
        }));
        return {
            label: Object.values(grouped[empId])[0].name,
            data: data,
            showLine: true,
            borderColor: colors[idx % colors.length],
            backgroundColor: colors[idx % colors.length],
            tension: 0.2,
            pointRadius: 4
        };
    });

    // Create Addiction Chart
    const ctx2 = document.getElementById('addictionChart').getContext('2d');
    
    // Get the full date range from all datasets
    let minDate = null;
    let maxDate = null;
    addictionDatasets.forEach(dataset => {
        dataset.data.forEach(point => {
            if (!minDate || point.x < minDate) minDate = point.x;
            if (!maxDate || point.x > maxDate) maxDate = point.x;
        });
    });
    
    // Add trend line dataset at -10 (which becomes 10 when made positive)
    const trendLineData = {
        label: 'Trend Line (10)',
        data: minDate && maxDate ? [
            { x: minDate, y: 10 },
            { x: maxDate, y: 10 }
        ] : [],
        borderColor: 'red',
        backgroundColor: 'red',
        borderWidth: 2,
        borderDash: [5, 5],
        pointRadius: 0,
        showLine: true,
        tension: 0
    };
    
    

    // Find people with current addiction <= -8 (high addiction)
    const highAddictionPeople = [];
    Object.keys(grouped).forEach(empId => {
        const employeeData = Object.values(grouped[empId]);
        if (employeeData.length > 0) {
            // Get most recent data for this employee
            const latestData = employeeData.reduce((latest, current) => 
                current.created_on > latest.created_on ? current : latest
            );
            const originalAddiction = latestData.effectiveness_addiction; // Original negative value
            const absoluteAddiction = Math.abs(originalAddiction);
            // Check if original addiction is -6 or lower (meaning high addiction)
            if (originalAddiction <= -6) {
                highAddictionPeople.push({
                    name: latestData.name,
                    employeeId: latestData.employee_id,
                    addiction: absoluteAddiction.toFixed(2),
                    originalValue: originalAddiction.toFixed(2),
                    date: latestData.created_on.slice(0, 10)
                });
            }
        }
    });

    // Display high addiction alert if there are any
    if (highAddictionPeople.length > 0) {
        const alertDiv = document.createElement('div');
        alertDiv.className = 'alert alert-warning mt-3 mb-3';
        alertDiv.style.textAlign = 'center';
        alertDiv.innerHTML = `
            <h5><i class="fas fa-exclamation-triangle"></i> High Addiction Alert (≤-8)</h5>
            <ul class="mb-0" style="list-style: none; padding: 0;">
                ${highAddictionPeople.map(person => 
                    `<li><strong><a href="https://www.torn.com/messages.php#/p=compose&XID=${person.employeeId}" target="_blank" style="color: #856404; text-decoration: none;">${person.name}</a></strong>: ${person.addiction} (original: ${person.originalValue}) (as of ${person.date})</li>`
                ).join('')}
            </ul>
        `;
        // Insert the alert before the addiction chart canvas
        const addictionChart = document.getElementById('addictionChart');
        addictionChart.parentNode.insertBefore(alertDiv, addictionChart);
    }

    /*
    // OLD CODE - COMMENTED OUT
    // Calculate 7-day rolling average addiction for the previous 7 days
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const fourteenDaysAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
    const sevenDaysAgoStr = sevenDaysAgo.toISOString().slice(0, 10);
    const fourteenDaysAgoStr = fourteenDaysAgo.toISOString().slice(0, 10);
    */

    /*
    // Group data for rolling average calculation (need 14 days of data)
    const rollingAvgGrouped = {};
    rawData.forEach(row => {
        const empId = row.employee_id;
        const date = row.created_on.slice(0, 10);
        if (date < fourteenDaysAgoStr) return; // skip if older than 14 days
        if (!rollingAvgGrouped[empId]) rollingAvgGrouped[empId] = {};
        if (!rollingAvgGrouped[empId][date] || rollingAvgGrouped[empId][date].created_on < row.created_on) {
            rollingAvgGrouped[empId][date] = row;
        }
    });

    // Calculate 7-day rolling averages for each employee for each of the last 7 days
    const rollingAvgData = Object.keys(rollingAvgGrouped).map((empId, idx) => {
        const employeeData = Object.values(rollingAvgGrouped[empId]);
        const employeeName = employeeData[0].name;
        
        // Sort data by date
        employeeData.sort((a, b) => a.created_on.localeCompare(b.created_on));
        
        const rollingAverages = [];
        
        // For each of the last 7 days, calculate the 7-day average ending on that day
        for (let i = 0; i < 7; i++) {
            const targetDate = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
            const targetDateStr = targetDate.toISOString().slice(0, 10);
            
            // Get 7 days of data ending on this target date
            const sevenDaysPrior = new Date(targetDate.getTime() - 6 * 24 * 60 * 60 * 1000);
            const sevenDaysPriorStr = sevenDaysPrior.toISOString().slice(0, 10);
            
            // Filter data for this 7-day window
            const windowData = employeeData.filter(row => {
                const rowDate = row.created_on.slice(0, 10);
                return rowDate >= sevenDaysPriorStr && rowDate <= targetDateStr;
            });
            
            // Calculate average for this window
            if (windowData.length > 0) {
                const avgAddiction = windowData.reduce((sum, row) => sum + Math.abs(row.effectiveness_addiction), 0) / windowData.length;
                rollingAverages.push({
                    x: targetDateStr,
                    y: avgAddiction
                });
            }
        }
        
        // Reverse to show oldest to newest
        rollingAverages.reverse();
        
        return {
            label: employeeName,
            data: rollingAverages,
            borderColor: colors[idx % colors.length],
            backgroundColor: colors[idx % colors.length],
            showLine: true,
            tension: 0.2,
            pointRadius: 4
        };
    });

    /*
    // OLD ROLLING AVERAGE CHART CODE - COMMENTED OUT FOR DATE RANGE FEATURE
    // Create 7-Day Rolling Average Addiction Chart
    const ctx3 = document.getElementById('avgAddictionChart').getContext('2d');
    new Chart(ctx3, {
        type: 'scatter',
        data: {
            datasets: rollingAvgData
        },
        options: {
            plugins: {
                legend: { display: true },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            return [
                                `${context.dataset.label}`,
                                `Date: ${context.raw.x}`,
                                `7-Day Avg Addiction: ${context.raw.y.toFixed(2)}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day' },
                    adapters: { date: window.luxon },
                    title: { display: true, text: 'Date' }
                },
                y: {
                    title: { display: true, text: '7-Day Rolling Average Addiction' }
                }
            }
        }
    });
    */
    
        }
    
    // END OLD CODE COMMENT */
    
    function createAddictionChart(data) {
        // First, identify which employees are current members
        const currentMemberIds = new Set();
        data.forEach(row => {
            if (row.is_current_member) {
                currentMemberIds.add(row.employee_id);
            }
        });
        
        // Filter data to only include current members
        const currentMemberData = data.filter(row => currentMemberIds.has(row.employee_id));
        
        // Group by employee and by day, keeping only the latest per day
        const grouped = {};
        currentMemberData.forEach(row => {
            const empId = row.employee_id;
            const date = row.created_on.slice(0, 10);
            if (!grouped[empId]) grouped[empId] = {};
            if (!grouped[empId][date] || grouped[empId][date].created_on < row.created_on) {
                grouped[empId][date] = row;
            }
        });

        // Prepare datasets for Addiction Chart
        const addictionDatasets = Object.keys(grouped).map((empId, idx) => {
            const chartData = Object.values(grouped[empId]).map(row => ({
                x: row.created_on.slice(0, 10),
                y: Math.abs(row.effectiveness_addiction), // Make addiction positive
                manual: row.manual_labour,
                intelligence: row.intelligence,
                endurance: row.endurance
            }));
            return {
                label: Object.values(grouped[empId])[0].name,
                data: chartData,
                showLine: true,
                borderColor: colors[idx % colors.length],
                backgroundColor: colors[idx % colors.length],
                tension: 0.2,
                pointRadius: 4
            };
        });

        // Get the full date range from all datasets for trend line
        let minDate = null;
        let maxDate = null;
        addictionDatasets.forEach(dataset => {
            dataset.data.forEach(point => {
                if (!minDate || point.x < minDate) minDate = point.x;
                if (!maxDate || point.x > maxDate) maxDate = point.x;
            });
        });

        // Add trend line dataset at 10
        const trendLineData = {
            label: 'Trend Line (10)',
            data: minDate && maxDate ? [
                { x: minDate, y: 10 },
                { x: maxDate, y: 10 }
            ] : [],
            borderColor: 'red',
            backgroundColor: 'red',
            borderWidth: 2,
            borderDash: [5, 5],
            pointRadius: 0,
            showLine: true,
            tension: 0
        };

        // Create Addiction Chart
        const ctx2 = document.getElementById('addictionChart').getContext('2d');
        addictionChart = new Chart(ctx2, {
            type: 'scatter',
            data: {
                datasets: [...addictionDatasets, trendLineData]
            },
            options: {
                plugins: {
                    legend: { display: true },
                    tooltip: {
                        filter: function(tooltipItem) {
                            return tooltipItem.datasetIndex !== addictionDatasets.length;
                        },
                        callbacks: {
                            label: function (context) {
                                const d = context.raw;
                                return [
                                    `${context.dataset.label}`,
                                    `Date: ${d.x}`,
                                    `Addiction: ${d.y}`,
                                    `Manual: ${d.manual}`,
                                    `Intelligence: ${d.intelligence}`,
                                    `Endurance: ${d.endurance}`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'day' },
                        adapters: { date: window.luxon },
                        title: { display: true, text: 'Date' }
                    },
                    y: {
                        title: { display: true, text: 'Addiction (Positive Values)' }
                    }
                }
            }
        });
    }
    
    function createRollingAverageChart(data, startDate, endDate) {
        // First, identify which employees are current members
        const currentMemberIds = new Set();
        data.forEach(row => {
            if (row.is_current_member) {
                currentMemberIds.add(row.employee_id);
            }
        });
        
        // Filter data to only include current members
        const currentMemberData = data.filter(row => currentMemberIds.has(row.employee_id));
        
        // Group data for rolling average calculation
        const rollingAvgGrouped = {};
        currentMemberData.forEach(row => {
            const empId = row.employee_id;
            const date = row.created_on.slice(0, 10);
            if (!rollingAvgGrouped[empId]) rollingAvgGrouped[empId] = {};
            if (!rollingAvgGrouped[empId][date] || rollingAvgGrouped[empId][date].created_on < row.created_on) {
                rollingAvgGrouped[empId][date] = row;
            }
        });

        // Calculate 7-day rolling averages for each employee
        const rollingAvgData = Object.keys(rollingAvgGrouped).map((empId, idx) => {
            const employeeData = Object.values(rollingAvgGrouped[empId]);
            if (employeeData.length === 0) return null;
            
            const employeeName = employeeData[0].name;
            employeeData.sort((a, b) => a.created_on.localeCompare(b.created_on));
            
            const rollingAverages = [];
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            // Calculate rolling averages for each day in the range
            const currentDate = new Date(start);
            while (currentDate <= end) {
                const targetDateStr = currentDate.toISOString().slice(0, 10);
                const sevenDaysPrior = new Date(currentDate.getTime() - 6 * 24 * 60 * 60 * 1000);
                const sevenDaysPriorStr = sevenDaysPrior.toISOString().slice(0, 10);
                
                const windowData = employeeData.filter(row => {
                    const rowDate = row.created_on.slice(0, 10);
                    return rowDate >= sevenDaysPriorStr && rowDate <= targetDateStr;
                });
                
                if (windowData.length > 0) {
                    const avgAddiction = windowData.reduce((sum, row) => sum + Math.abs(row.effectiveness_addiction), 0) / windowData.length;
                    rollingAverages.push({
                        x: targetDateStr,
                        y: avgAddiction
                    });
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            return {
                label: employeeName,
                data: rollingAverages,
                borderColor: colors[idx % colors.length],
                backgroundColor: colors[idx % colors.length],
                showLine: true,
                tension: 0.2,
                pointRadius: 4
            };
        }).filter(dataset => dataset !== null);

        // Create 7-Day Rolling Average Addiction Chart
        const ctx3 = document.getElementById('avgAddictionChart').getContext('2d');
        rollingAvgChart = new Chart(ctx3, {
            type: 'scatter',
            data: {
                datasets: rollingAvgData
            },
            options: {
                plugins: {
                    legend: { display: true },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                return [
                                    `${context.dataset.label}`,
                                    `Date: ${context.raw.x}`,
                                    `7-Day Avg Addiction: ${context.raw.y.toFixed(2)}`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'day' },
                        adapters: { date: window.luxon },
                        title: { display: true, text: 'Date' }
                    },
                    y: {
                        title: { display: true, text: '7-Day Rolling Average Addiction' }
                    }
                }
            }
        });
    }
    
    // Function to toggle the expanded view of inactivity members
    function toggleInactivityExpand() {
        const remainingList = document.getElementById('remainingList');
        const expandBtn = document.getElementById('expandInactivityBtn');
        
        if (remainingList.style.display === 'none') {
            remainingList.style.display = 'block';
            expandBtn.textContent = 'Show fewer members';
            expandBtn.classList.remove('btn-outline-info');
            expandBtn.classList.add('btn-info');
        } else {
            remainingList.style.display = 'none';
            const hiddenCount = remainingList.children.length;
            expandBtn.textContent = `Show ${hiddenCount} more members`;
            expandBtn.classList.remove('btn-info');
            expandBtn.classList.add('btn-outline-info');
        }
    }
    
    // Event listeners and initialization
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM Content Loaded - setting up date range feature');
        
        // Initialize date inputs
        initializeDateInputs();
        console.log('Date inputs initialized');
        
        // Create initial charts with default range
        createCharts();
        console.log('Initial charts created');
        
        // Add event listeners
        const updateButton = document.getElementById('updateCharts');
        if (updateButton) {
            updateButton.addEventListener('click', function() {
                console.log('Update Charts button clicked!');
                createCharts();
            });
            console.log('Update button event listener added');
        } else {
            console.error('Update Charts button not found!');
        }
        
        const resetButton = document.getElementById('resetRange');
        if (resetButton) {
            resetButton.addEventListener('click', function() {
                console.log('Reset Range button clicked!');
                initializeDateInputs();
                createCharts();
            });
            console.log('Reset button event listener added');
        } else {
            console.error('Reset Range button not found!');
        }
    });
</script>
{% endblock content %}